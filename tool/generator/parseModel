#!/usr/bin/env node
/* Mongo model parser
 * @author Michal Tanecek
 * @version 0.0.7
 * @licence BSD
 * @todo: Relations

 *Â version history:
 * 0.0.7:
 * replace whitespaces with tab \x20{4} => \t
 * 0.0.6:
 * added support fot validate callback functions
 * added support for buld-in validators min,max,match
 * added toString functionality for default values - functions
 * fix for default values: false (Boolean ..)
 * add support for mongoose enum - select tag
 * remove forEach break hack
 * cleaned code
 * minor changes for tamplate
 * 0.0.5:
 * initial import
 */
var  program = require('commander')
	,fs = require('fs')
	,path = require('path')
	;

var _model;
var _path;
var _schema = {};
var _modelFile;
var _patches = '//[patches\n\n\n//patches]';

var primitives = ['Email','Url','Number','Date','Boolean','String'];
var inputConversion = {'Email': 'email','Url': 'url', 'Number':'number','Date':'date','Boolean':'checkbox','String':'text'};
var marks = ['required','unique','disabled','disabled'];
var filters = ['lowercase' ,'uppercase','trim'];

program
  .version('0.0.7')
  .option('-m, --model [name]', 'Set model')
  .option('-p, --path [path]','Set custom model path', path.normalize('../../app/model'))
  .option('-f, --force','Force parser to rewrite exists file')
  .option('-r, --revision','Set model revision','0.0.1')
  .parse(process.argv);


if(!program.model) {
	console.error('Error: Provide model, for more information run script with --help argument.')
	process.exit();
}
_path = path.normalize(program.path);

if(program.model.match('/.js$/'))
	_modelFile = _path+'/'+program.model.replace('/.js$/','');
else
	_modelFile = _path+'/'+program.model;

_model = require(_modelFile);

var file = path.normalize(_path +'/'+program.model+'.parsed.js');


_schema = JSON.stringify(parse(_model.schema.tree),undefined, 4);

while(_schema.match(/\x20{4}/)) {
	_schema = _schema.replace(/\x20{4}/,'\t');
}

if(fs.existsSync(file) && !program.force) {
	var data = fs.readFileSync(file).toString();
	var patches = data.match(/\/\/\[patches(.|[\r\n])*\/\/patches\]/);
	if(Array.isArray(patches)) {
		patches = patches[0];
	}
	_patches = patches; 
} 
var _tmpl = [
	 '/*\n'
	,' * Parsed mongoose model - `#model#`\n'
	,' * @revision #revision#\n'
	,' * @parser_version #parser_version#\n'
	,' * @generated #iso#\n'
	,' */\n\n'
	,'//[\n'
	,'var model = {};\n'
	,'var mongooseModel = require(\'#modelFile#\');\n'
	,'model.schema = mongooseModel.schema;\n'
	,'model.entity = mongooseModel.model;\n'
	,'model.form = {};\n'
	,'var schema = JSON.parse('
	,'#schema#'
	,');\n'
	,'//]\n'
	,'#patches#'
	,'\nmodel.form.schema = schema;'
	,'\nexports = module.exports = model;'
];
var replaces = {
	 'model' : program.model
	,'revision': program.revision
	,'parser_version': program._version
	,'iso' : (new Date).toISOString()
	,'modelFile' : _modelFile
	,'schema': _schema
	,'patches' : _patches
};
_tmpl = vocabulary_replace(replaces,_tmpl.join(''));
fs.writeFileSync(file,_tmpl)


function vocabulary_replace(source,target) {
	var  strings = Object.getOwnPropertyNames(source)
		,i = 0;
	for(; i < strings.length; i++) {
		target = target.replace('#'+strings[i]+'#',source[strings[i]]);
	}
	return target;
}


function parse(source) {
	var target = {};
	var props = Object.getOwnPropertyNames(source);
	var i;
	for(i =0; i < props.length; i++) {
		// simple types
		if(typeof source[props[i]] == 'function') {
			var j;
			for(j =0; j < primitives.length; j++) {
				var item = primitives[j];
				var re = new RegExp(item,"g");
				if((source[props[i]].toString().match(re) || item == 'String') && (props[i] != '__v')) {
					target[props[i]] = {
						type: inputConversion[item]
					}
				}
			break;
			}
		} 
		// objects
		else {
			// field
			if(typeof source[props[i]].type != 'undefined') {
				var type = (source[props[i]].type.toString()).replace('function ','')
				if(props[i] == '_id') {
					target[props[i]] = {
						type: 'Text',
						pk : true
					}
				} else {
					var j;
					for(j =0; j < primitives.length; j++) {
						var item = primitives[j];
						var re = new RegExp('^'+item,"g");
						var field = source[props[i]];
						
						if(type.match(re) || item == 'String') {
								target[props[i]] = {
								type: inputConversion[item]
							}
							
							marks.forEach(function(j){
								if(field[j])
									target[props[i]][j] = true;
							});
							
							filters.forEach(function(j){
								if(field[j]) {
									if(target[props[i]].filters === undefined)
										target[props[i]].filters = [];
									target[props[i]].filters.push(j);
								}
							});
							
							if(field.validate) {
								if(!Array.isArray(target[props[i]].validators))
									target[props[i]].validators = [];

								if(Array.isArray(field.validate)) {
									if(typeof field.validate[0].toString !== undefined) {
										target[props[i]].validators.push([field.validate[0].toString(),field.validate[1]]);
									} else {
										console.log('Unkown function as default value for field props[i], using JSON.stringify, so check it plese in result.')
										target[props[i]].validators.push([JSON.stringify(field[0].validate),field.validate[1]]);
									}

								} else {
									if(typeof field.validate.toString !== undefined) {
										target[props[i]].validators.push(field.validate.toString());
									} else {
										console.log('Unkown function as default value for field props[i], using JSON.stringify, so check it plese in result.')
										target[props[i]].validators.push(JSON.stringify(field.validate));
									}
								}
							}

							if(field.enum) {
								target[props[i]].type = 'select';
								target[props[i]].options = field.enum;
							}
							
							if(field.fulltext)
								target[props[i]].type = 'textarea';
							
							if(field.default !== undefined) {
								switch(typeof field.default) {
									case 'function':
										if(typeof field.default.toString !== undefined) {
											var def = field.default.toString();
											if(def.match(/^function now/)) {
												var fn = new Function('return new Date()');
												target[props[i]].default = fn.toString();
											} else {
												target[props[i]].default = field.default.toString();
											} 
										} else {
											console.log('Unkown function as default value for field props[i], using JSON.stringify, so check it plese in result.')
											target[props[i]].default = JSON.stringify(field.default);
										}
									break;

									default:
										target[props[i]].default = field.default;
									break; 
								}
								
							}
							// build-in validators
							if(field.min) {
								if(!Array.isArray(target[props[i]].validators))
									target[props[i]].validators = [];
								
								var fn = ['if (v <',field.min,') {return false;} else {return true;}'] 
								target[props[i]].validators.push(new Function('v',fn.join('')).toString());
							}
							if(field.max) {
								if(!Array.isArray(target[props[i]].validators))
									target[props[i]].validators = [];
								
								var fn = ['if (v >',field.max,') {return false;} else {return true;}'] 
								target[props[i]].validators.push(new Function('v',fn.join('')).toString());
							}
							if(field.match !== undefined) {
								if(!Array.isArray(target[props[i]].validators))
									target[props[i]].validators = [];
								
								var fn = ['if (v.match(<',field.match.toString(),')) {return true;} else {return false;}'] 
								target[props[i]].validators.push(new Function('v',fn.join('')).toString());

							}
						break;
						}
					}
				}
			} 
			// array of fields .. or error in schema
			else {
				target[props[i]] = parse(source[props[i]]);
			}
		}
	}
	return target;
}